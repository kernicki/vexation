* Houdini VEX Sandbox
** About
A set of simple functions compiled into a library (written in Side FX Houdini VEX language). The libray would allow to run some more abstract tasks for a given set of requirements and circumstances. (Either by processing existing geometry, or generating everything entirely from scratch).  It is in a very early state. Yet to be tested and tweaked, and well thought through. (To be elaborated...)
As an integral part of generalized functions there are also assemblies, practical constructs that are primary users of the library.
Assemblies would represent more complex solutions. First of the series is an assembly - Voronoi (clusters) FLD, comprised of 3 stages, each making its own thing ready for branching and developing something other than serving the described below goal and conditions. 
** Functions
TBD
*** Array
Functions for working with arrays.
**** in_the
Takes an array and an element and checks if the element is __in__the array. (Similar to Python 'in' operator)
Works with int and string arrays. Used to build sets with unique values.

#+BEGIN_SRC C
  int in_the(int array[];int member;){
    foreach (int num; array) {
      if( num == member ) return 1;}
    return 0;}
#+END_SRC
**** append_if_not_in
Appends element if it is not in the array.

#+BEGIN_SRC C
  int append_if_not_in(int array[];int member;) {
    if( !in_the(array,member ) ){
      push (array,member);
      return 1;}
    else return 0;
  }
#+END_SRC
*** Math
**** Cubic spline
Calculate a point on a cubic spline for the points given at t.
#+BEGIN_SRC C
  vector target( vector P0; vector P1; vector P2; vector P3; float t ){
    if (t > 1) t = 1;
    if (t < 0) t = 0;
    float b1 = (1-t) ;
    vector target1 = pow(b1,3)*P0 + 3*pow(b1,2)*t*P1 + 3*b1*pow(t,2)*P2 + pow(t,3)*P3;
    return target1;
  }
#+END_SRC
*** Mesh
**** build_the_link_4
Builds the link (polyline) between a pair of primitives, expressed as a string. 
Returns number of the resulting primitive.
#+BEGIN_SRC C
  int build_the_link_4(string prim_pair){
    string b[] = split(prim_pair,"_");
    int first = atoi(b[0]);
    int second = atoi(b[1]);
    vector p1 = prim(0, "P", first);
    vector p2 = prim(0, "P", second);
    int pt1 = addpoint(0, p1);
    int pt2 = addpoint(0, p2);
    int pr = addprim(0, "polyline", pt1, pt2);
    setpointattrib( 0, "prim", pt1, first );
    setpointattrib( 0, "prim", pt2, second );
    return pr;
  }
#+END_SRC



** Assemblies
*** FLD
An algorithm that fractures existing surface into a number of pieces with concave shapes and very defined border.  
**** Terms and conditions
For the given set of primitives(very well triangulated) each with its own group Id, distort their boundary so that Voronoi classes (neighborhoods) start degrading losing their primitives to their neighbors. For all those make it so that they do not have inner regions also. After that make iterable boundaries between newly generated groups, and loft with the boundary hulls presented by the edges of bordering simplexes (aka. triangles) with cubic (very smooth) interpolation. And deform again to make profile look rougher, that is - more natural. 
**** Stages (FLD)
***** deForm and deFragment
First displace point samples so that they intersect with nearest neighbors, so breaking up the wholeness of the group they belong to. Next, use class semantics and a simple rule: if class-A is more numerous than class-B (both always be neighbors, of course), class-A should engulf class-B, and re-assign its primitives' membership to class-A. The minimum number of primitives, that are to be null-ed, is to be proportional to the Voronoi cell radius, and higher. Up to final dual-ness of the 2 resulting pieces that share only one border. Thus, the resulting clusters have non-deterministic look to them, as it is the case with many existing fracturing solutions that are grounded on Voronoi tessellation. 
***** Lofting
The newly generated border primitives are fully aware of each other, and are ready to be subdivided and refined. Since the sequence of bordering points is now iterable (there is a sequential class-pair iterator), one can apply a series of heuristics to make uninterrupted subdivision possible by splitting the triangles at certain locations(such as split the primitive if one is surrounded by 2 different classes, and one of its neighbors shares 2 edges with another class, and so on). Some heuristics definitely could be better, but for now it is enough to build a safe profile of subdivision between new fragments. With control points being the vertices of the simplexes. 
***** Disturbing (again)
Lofting yields a very dull, eroded profile. By using existing free space to perturb the points, generated by the subdivision, we can gently pull vertices along the averages of the incident edges (that do not share the border). As if sliding them tangentially. Not ideal, but it gives a very perceptible breakup at a certain distance.
**** Use cases
The algorithm can be used in many different areas, such as:
- Fracturing rigid bodies (though the resulting shapes can be costly concaves),
- Fracturing cloth objects with a natural, non-uniform pre-cuts.
- Generating naturally occuring cracks and patterns(giraffe stains).
- Terrains with predefined paths, trails, routes, and beaches. 
- Scientific and data visualizations (via class-topology relations)
*** Usage
#+begin_src bash :results verba// return 1 if en elem is __ in the __ array (similar to Python's in() )
int in_the(int array[];int member;){
  foreach (int num; array) {
    if( num == member ) return 1;}
  return 0;
}tim 
git clone https://github.com/kernicki/vexation.git
cd vexation/
houdini hips/voronoi_fld_v002.hipnc
#+end_src 
*** References
- [[https://www.sidefx.com/docs/houdini/vex/halfedges.html][Houdini Half-edges]]
  Is a must to know and comfortable to work with, as they represent a very powerful tool to iterate over the mesh.
- [[https://blogs.scientificamerican.com/observations/voronoi-tessellations-and-scutoids-are-everywhere/][Voronoi tessellations are ubiquitous]]
- [[https://en.wikipedia.org/wiki/Voronoi_diagram#Applications][They really are]]
- [[https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm][k-NN]]
  The whole idea might be transposed onto how we classify stuff in ML. Albeit on a very rudimentary level. We can identify classes spatially, and there is a geomtry intuition for that. The blue spot should never be inside a red one ...
* Future
Future plans is to extend functionality of the library with new ideas and solutions.
* Goal
Each and every node on a SOP-level may well be replaced with a VEX-code wrangle, that in turn could source a text file from disk, which one can control with IDE or even AI, and then enhance with some more abstract and fine granular logic run on top of the whole hierarchy of nodes being evaluated. But it is just an idea... 
